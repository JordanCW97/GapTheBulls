<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gap The Bulls!</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
            overflow: hidden;
            border: 3px solid #ff6600;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
            touch-action: none;
        }

        .ui {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #score {
            top: 20px;
            left: 70px;
            font-size: 24px;
        }

        #speedIndicator {
            top: 20px;
            right: 20px;
            font-size: 18px;
            text-align: right;
        }

        #audioToggle {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ff6600;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            transition: all 0.3s ease;
            z-index: 15;
            user-select: none;
            touch-action: manipulation;
        }

        #audioToggle:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        #audioToggle.muted {
            color: #ff6666;
            border-color: #ff6666;
        }

        #instructions {
            top: 60px;
            right: 20px;
            font-size: 14px;
            text-align: right;
        }

        #introText {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
        }

        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 30;
            border: 2px solid #ff6600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
        }

        #howToPlay, #credits {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 30;
            border: 2px solid #ff6600;
            display: none;
            flex-direction: column;
            box-sizing: border-box;
            width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        #mainMenu {
            display: flex;
        }

        #howToPlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 30;
            border: 2px solid #ff6600;
            display: none;
            flex-direction: column;
            box-sizing: border-box;
            width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        @media (max-width: 480px) {
            #howToPlay,
            #credits {
                padding: 20px;
                width: 95vw;
                max-height: 85vh;
            }
        }

        .menu-center {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .driver-image {
            width: 120px;
            height: auto;
            opacity: 0.9;
        }

        .driver-image.lando {
            align-self: flex-start;
        }

        .driver-image.max {
            align-self: flex-end;
        }

        .menu-title {
            color: #ff6600;
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .menu-title-image {
            max-width: 100%;
            width: 300px;
            height: auto;
            margin-bottom: 30px;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.7));
        }


        .menu-button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: background 0.3s;
            display: block;
            width: 200px;
            margin: 10px auto;
            touch-action: manipulation;
        }

        .menu-button:hover {
            background: #e55a00;
        }

        .back-button {
            background: #666;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
        }

        .back-button:hover {
            background: #555;
        }

        .menu-content {
            color: white;
            line-height: 1.5;
            text-align: left;
            max-width: 100%;
            font-size: 14px;
        }

        .menu-content h3 {
            color: #ff6600;
            text-align: center;
        }

        #gameOver h2 {
            color: #ff6600;
            margin-top: 0;
            font-size: 28px;
        }
        #gameOver p {
            color: #ffffff;
        }

        #gameOver button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: background 0.3s;
            touch-action: manipulation;
        }

        #gameOver button:hover {
            background: #e55a00;
        }

        .road-line {
            position: absolute;
            width: 60px;
            height: 4px;
            background: white;
            bottom: 150px;
            animation: roadMove 1s linear infinite;
        }

        @keyframes roadMove {
            from { right: -60px; }
            to { right: 100%; }
        }

        @media (max-width: 768px) and (orientation: portrait) {
            #gameContainer {
                border: none;
                max-width: none;
                max-height: none;
                border-radius: 0;
            }

            #score {
                font-size: 16px;
                left: 65px;
                top: 15px;
            }

            #speedIndicator {
                font-size: 14px;
                top: 15px;
            }

            #instructions {
                font-size: 12px;
                top: 50px;
            }

            #gameOver h2 {
                font-size: 24px;
            }

            #gameOver button {
                font-size: 16px;
                padding: 10px 20px;
            }

            #audioToggle {
                width: 35px;
                height: 35px;
                font-size: 18px;
                top: 15px;
                left: 15px;
            }

            .menu-title {
                font-size: 28px;
            }

            .driver-image {
                width: 80px;
            }

            #mainMenu, #howToPlay, #credits {
                padding: 20px;
                gap: 20px;
            }
        }

        @media (max-width: 480px) {
            .menu-title {
                font-size: 24px;
            }

            .menu-button {
                font-size: 16px;
                padding: 12px 24px;
                width: 150px;
            }

            .driver-image {
                width: 60px;
            }
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="audioToggle" onclick="toggleAudio()" title="Toggle Audio">🔊</div>

    <div id="score" class="ui">Championship points: 0</div>
    <div id="speedIndicator" class="ui">Speed: 0 km/h</div>
    <div id="instructions" class="ui">
        Hold to Jump Higher<br>
    </div>

    <div id="introText" class="ui">
        Max is pulling away!
    </div>

    <div id="mainMenu">
        <img id="landoImg" class="driver-image lando" style="display: none;">
        <div class="menu-center">
            <img src="./Resources/Art/Title.png" alt="Gap The Bulls Title" class="menu-title-image">
            <button class="menu-button" onclick="startGame()">Play</button>
            <button class="menu-button" onclick="showHowToPlay()">How to Play</button>
            <button class="menu-button" onclick="showCredits()">Credits</button>
        </div>
        <img id="maxImg" class="driver-image max" style="display: none;">
    </div>

    <div id="howToPlay">
        <h1 class="menu-title">How to Play</h1>
        <div class="menu-content">
            <h3>Objective:</h3>
            <p>Help McLaren gap the Red Bull second drivers, but you'll never quite catch Max Verstappen!</p>

            <h3>Controls:</h3>
            <p>• Hold Click/Tap for higher jumps</p>
            <p>• Quick tap for small hops</p>
            <p>• Watch the charge bar above your car!</p>

            <h3>Mobile Tips:</h3>
            <p>• Look for red warning indicators showing incoming obstacles</p>
            <p>• Yellow zones indicate perfect jump timing</p>
            <p>• Speed indicator helps you anticipate difficulty</p>

            <h3>Gameplay:</h3>
            <p>• Jump over Red Bull cars to earn championship points</p>
            <p>• The game gets faster and more challenging as you progress</p>
            <p>• Watch out for obstacle clusters!</p>
            <p>• Don't crash into the Red Bull cars!</p>
        </div>
        <button class="menu-button back-button" onclick="showMainMenu()">Back</button>
    </div>

    <div id="credits">
        <h1 class="menu-title">Credits</h1>
        <div class="menu-content">
            <h3>Game Development:</h3>
            <p>Jordan Carter-Wightwick</p>

            <h3>Inspired by:</h3>
            <p>Charlotte's poor choice in F1 teams.</p>

            <h3>Special Thanks:</h3>
            <p>To all F1 fans who know the pain of watching Max dominate the sport!</p>

            <h3>Remember:</h3>
            <p>"It's lights out and away we go!" 🏁</p>
        </div>
        <button class="menu-button back-button" onclick="showMainMenu()">Back</button>
    </div>

    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Oops! Max made McLaren look bad again!</p>
        <p id="finalScore">Final Score: 0</p>

        <div style="margin-top: 20px;">
            <input id="playerNameInput" type="text" placeholder="Enter your name" maxlength="12"
                   style="padding: 8px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc;">
            <button onclick="submitHighScore()" style="margin-left: 10px;">Submit Score</button>
        </div>

        <div id="highScoresContainer" style="margin-top: 20px; text-align: center;">
            <h3 style="color: #ff6600;">High Scores</h3>
            <table id="highScoresTable" style="width: 100%; color: white; font-size: 14px; border-collapse: collapse;">
                <thead>
                <tr>
                    <th style="text-align: left; padding: 4px;">Player</th>
                    <th style="text-align: right; padding: 4px;">Score</th>
                </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <button onclick="restartGame()">Try Again</button>
        <button class="back-button" onclick="showMainMenu()" style="margin-left: 10px;">Main Menu</button>
    </div>

    <audio id="backgroundMusic" loop>
        <source src="./Resources/Audio/theme.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let devicePixelRatio = window.devicePixelRatio || 1;
    let displayWidth, displayHeight;
    let canvasWidth, canvasHeight;
    let isMobilePortrait = false;

    const backgroundMusic = document.getElementById('backgroundMusic');
    const audioToggle = document.getElementById('audioToggle');
    let isAudioMuted = false;
    let audioInitialized = false;

    backgroundMusic.volume = 0.3;

    const TARGET_FPS = 60;
    const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
    let lastFrameTime = 0;
    let deltaTimeAccumulator = 0;

    function checkMobilePortrait() {
        isMobilePortrait = window.innerWidth < 768 && window.innerHeight > window.innerWidth;
        return isMobilePortrait;
    }

    function initializeAudio() {
        if (!audioInitialized && !isAudioMuted) {
            backgroundMusic.play().then(() => {
                audioInitialized = true;
                console.log('Audio initialized and playing successfully');
            }).catch(error => {
                console.log('Audio initialization failed:', error);
            });
        }
    }

    function startAudio() {
        if (!isAudioMuted) {
            if (!audioInitialized) {
                initializeAudio();
            } else {
                backgroundMusic.play().catch(error => {
                    console.log('Failed to play audio:', error);
                });
            }
        }
    }

    function toggleAudio() {
        if (!audioInitialized) {
            initializeAudio();
        }

        isAudioMuted = !isAudioMuted;

        if (isAudioMuted) {
            backgroundMusic.pause();
            audioToggle.textContent = '🔇';
            audioToggle.classList.add('muted');
            audioToggle.title = 'Unmute Audio';
        } else {
            backgroundMusic.play().catch(error => {
                console.log('Failed to play audio:', error);
            });
            audioToggle.textContent = '🔊';
            audioToggle.classList.remove('muted');
            audioToggle.title = 'Mute Audio';
        }
    }

    function submitHighScore() {
        const nameInput = document.getElementById('playerNameInput');
        const playerName = nameInput.value.trim() || 'Anonymous';

        fetch('https://gap-the-bulls-api.onrender.com/api/scores', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                username: playerName,
                score: score
            })
        })
            .then(response => {
                return response.json
            })
            .then(data => {
                console.log('Score submitted:', data);
                nameInput.disabled = true;
                renderHighScores();
            })
            .catch(error => {
                console.error('Failed to submit score:', error);
                alert("Failed to submit score. Please try again later.");
            });
    }

    function renderHighScores() {
        const tbody = document.querySelector('#highScoresTable tbody');
        tbody.innerHTML = '<tr><td colspan="2" style="text-align:center;">Loading...</td></tr>';

        fetch('https://gap-the-bulls-api.onrender.com/api/scores')
            .then(response => {
                console.log(response)
                return response.json();
            })
            .then(data => {
                tbody.innerHTML = '';
                const scores = data.data;

                scores
                    .sort((a, b) => b.score - a.score) 
                    .slice(0, 5)
                    .forEach(entry => {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td style="padding: 4px;">${entry.username}</td><td style="text-align: right; padding: 4px;">${entry.score}</td>`;
                        tbody.appendChild(row);
                    });
            })
            .catch(error => {
                console.error('Failed to load high scores:', error);
                tbody.innerHTML = '<tr><td colspan="2" style="text-align:center;">Error loading scores</td></tr>';
            });
    }

    function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        const containerRect = container.getBoundingClientRect();

        displayWidth = containerRect.width;
        displayHeight = containerRect.height;

        checkMobilePortrait();

        canvasWidth = displayWidth * devicePixelRatio;
        canvasHeight = displayHeight * devicePixelRatio;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';

        ctx.scale(devicePixelRatio, devicePixelRatio);

        updateGameDimensions();
    }

    let gameState = 'menu';
    let gameRunning = false;
    let score = 0;
    let gameTime = 0;
    let introStartTime = 0;
    const introDuration = 3000;

    let backgroundOffset = 0;

    let isInputDown = false;
    let chargeStartTime = 0;
    let wantsToCharge = false;

    const player = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        velocityY: 0,
        grounded: false,
        minJumpPower: -300,
        maxJumpPower: -700,
        gravity: 1600,
        isCharging: false,
        chargeTime: 0,
        maxChargeTime: 300
    };

    const maxCar = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        speed: 0,
        visible: false
    };

    const obstacles = [];
    const activeQuotes = [];
    let obstacleSpawnRate = 1800;
    let obstacleSpeed = 800;
    let minObstacleGap = 0;
    let lastObstacleTime = 0;
    let difficultyLevel = 0;
    let obstacleClusterChance = 0.3;

    let grandstandTimer = 0;
    let grandstandVisible = true;
    let grandstandX = 0;
    let grandstandSpeed = 0;
    const grandstandInterval = 15000 + Math.random() * 5000; 

    let warningZone = 0; 
    let perfectJumpZone = 0;

    const overtakeQuotes = [
        "They race me so hard...",
        "Du du du du!",
        "No papaya rules here!",
        "Look at me now Zak!",
        "Oh look it's Liam Slowson!",
        "Box this lap? Nah, I’m boxing rivals instead.",
        "That's how it's done, baby!",
        "Maximum attack, let's go!",
        "Is that a Red Bull or a traffic cone?",
        "Smooth operator coming through!",
        "Send it like it's Silverstone!",
        "Clear air and clear conscience.",
        "Lando mode: engaged.",
        "This one's for Team Papaya!",
        "Tell Oscar I said hi.",
        "I need party mode!.",
        "It's friday nightttt! Saturday sunday what?.",
    ];

    let groundY;

    function updateGameDimensions() {
        if (isMobilePortrait) {
            player.width = 44;
            player.height = 22;
            player.x = displayWidth * 0.1;

            warningZone = displayWidth * 0.75;
            perfectJumpZone = displayWidth * 0.5;

            obstacleSpeed = Math.max(600, obstacleSpeed * 0.8);
            obstacleSpawnRate = Math.max(2000, obstacleSpawnRate * 1.2);
        } else {
            player.width = 50;
            player.height = 26;
            player.x = displayWidth * 0.1;

            warningZone = displayWidth * 0.4;
            perfectJumpZone = displayWidth * 0.25;
        }

        maxCar.width = player.width;
        maxCar.height = player.height;
        maxCar.x = displayWidth * 0.225;

        groundY = displayHeight - Math.min(100, displayHeight * 0.167);
        minObstacleGap = Math.max(isMobilePortrait ? 140 : 120, displayWidth * 0.15);

        if (player.grounded) {
            player.y = groundY - player.height;
        }
        maxCar.y = groundY - maxCar.height;
    }

    const treeImage = new Image();
    let treeImageLoaded = false;
    treeImage.onload = function() { treeImageLoaded = true; };
    treeImage.onerror = function() { treeImageLoaded = false; };
    treeImage.src = './Resources/Sprites/tree_cartoon_med.png';

    const mclarenImage = new Image();
    const redBullImage = new Image();
    let mclarenImageLoaded = false;
    let redBullImageLoaded = false;
    mclarenImage.onload = function() { mclarenImageLoaded = true; };
    mclarenImage.onerror = function() { mclarenImageLoaded = false; };
    redBullImage.onload = function() { redBullImageLoaded = true; };
    redBullImage.onerror = function() { redBullImageLoaded = false; };
    mclarenImage.src = './Resources/Sprites/MCL.png';
    redBullImage.src = './Resources/Sprites/RB.png';

    const grandstandImage = new Image();
    let grandstandImageLoaded = false;
    grandstandImage.onload = () => grandstandImageLoaded = true;
    grandstandImage.onerror = () => grandstandImageLoaded = false;
    grandstandImage.src = './Resources/Sprites/grandstand.png';

    const landoImage = new Image();
    const maxImage = new Image();
    let landoImageLoaded = false;
    let maxImageLoaded = false;
    landoImage.onload = function() { landoImageLoaded = true; updateDriverImages(); };
    landoImage.onerror = function() { landoImageLoaded = false; };
    maxImage.onload = function() { maxImageLoaded = true; updateDriverImages(); };
    maxImage.onerror = function() { maxImageLoaded = false; };
    landoImage.src = './Resources/Sprites/Lando.png';
    maxImage.src = './Resources/Sprites/Max.png';

    function updateDriverImages() {
        if (gameState === 'menu') {
            if (landoImageLoaded) {
                const landoImg = document.getElementById('landoImg');
                landoImg.src = landoImage.src;
                landoImg.style.display = 'block';
            }
            if (maxImageLoaded) {
                const maxImg = document.getElementById('maxImg');
                maxImg.src = maxImage.src;
                maxImg.style.display = 'block';
            }
        }
    }

    function startCharging() {
        wantsToCharge = true;
        if (player.grounded && !player.isCharging) {
            player.isCharging = true;
            chargeStartTime = gameTime;
        }
    }

    function stopCharging() {
        wantsToCharge = false;
        player.isCharging = false;
        chargeStartTime = 0;
    }

    function executeJump() {
        if (player.isCharging && player.grounded) {
            const chargeTime = gameTime - chargeStartTime;
            const chargeRatio = Math.min(chargeTime / player.maxChargeTime, 1);
            const jumpPower = player.minJumpPower + (player.maxJumpPower - player.minJumpPower) * chargeRatio;

            player.velocityY = jumpPower;
            player.grounded = false;
            player.isCharging = false;
            chargeStartTime = 0;

            if (player.y >= groundY - player.height) {
                player.y = groundY - player.height - 1;
            }
        }
    }

    function drawMcLaren(x, y) {
        if (mclarenImageLoaded && mclarenImage.complete) {
            const spriteAspectRatio = mclarenImage.width / mclarenImage.height;
            const scaledWidth = player.height * spriteAspectRatio;
            ctx.drawImage(mclarenImage, x, y, scaledWidth, player.height);
        } else {
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(x, y, player.width, player.height);
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + player.width * 0.0625, y + player.height * 0.125, player.width * 0.1875, player.height * 0.2);
            ctx.fillRect(x + player.width * 0.75, y + player.height * 0.125, player.width * 0.1875, player.height * 0.2);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = player.height * 0.2;
            ctx.arc(x + player.width * 0.1875, y + player.height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + player.width * 0.8125, y + player.height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = `${player.height * 0.3}px Arial`;
            ctx.fillText('MCL', x + player.width * 0.3125, y + player.height * 0.625);
        }

        if ((player.isCharging && (player.grounded || player.velocityY >= 0)) ||
            (wantsToCharge && !player.grounded)) {
            const chargeRatio = player.isCharging ?
                Math.min((gameTime - chargeStartTime) / player.maxChargeTime, 1) : 0;
            const barWidth = isMobilePortrait ? 50 : 60;
            const barHeight = isMobilePortrait ? 5 : 6;
            const barX = x + (player.width - barWidth) / 2;
            const barY = y - (isMobilePortrait ? 12 : 15);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            if (player.isCharging) {
                const chargeWidth = barWidth * chargeRatio;
                if (chargeRatio < 0.5) {
                    ctx.fillStyle = '#00ff00';
                } else if (chargeRatio < 0.8) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                ctx.fillRect(barX, barY, chargeWidth, barHeight);
            } else if (wantsToCharge) {
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(barX, barY, barWidth * 0.1, barHeight);
            }

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }

    function drawRedBull(x, y, width, height, showWarning = false, showPerfectZone = false) {
        if (redBullImageLoaded && redBullImage.complete) {
            const spriteAspectRatio = redBullImage.width / redBullImage.height;
            const scaledWidth = height * spriteAspectRatio;
            ctx.drawImage(redBullImage, x, y, scaledWidth, height);
        } else {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(x + width * 0.0714, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillRect(x + width * 0.7571, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = height * 0.15;
            ctx.arc(x + width * 0.1714, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + width * 0.8286, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = `${height * 0.25}px Arial`;
            const textWidth = ctx.measureText('RB').width;
            ctx.fillText('RB', x + (width - textWidth) / 2, y + height * 0.625);
        }
    }

    function drawMaxRedBull(x, y, width, height) {
        if (redBullImageLoaded && redBullImage.complete) {
            const spriteAspectRatio = redBullImage.width / redBullImage.height;
            const scaledWidth = height * spriteAspectRatio;
            ctx.drawImage(redBullImage, x, y, scaledWidth, height);
        } else {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x + width * 0.0714, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillRect(x + width * 0.7571, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = height * 0.15;
            ctx.arc(x + width * 0.1714, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + width * 0.8286, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.font = `${height * 0.25}px Arial`;
            const textWidth = ctx.measureText('MV').width;
            ctx.fillText('MV', x + (width - textWidth) / 2, y + height * 0.625);
        }
    }

    function showMainMenu() {
        gameState = 'menu';
        gameRunning = false;
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('howToPlay').style.display = 'none';
        document.getElementById('credits').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('score').style.display = 'none';
        document.getElementById('speedIndicator').style.display = 'none';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('introText').style.display = 'none';
        updateDriverImages();
    }

    function showHowToPlay() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('howToPlay').style.display = 'block';
    }

    function showCredits() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('credits').style.display = 'block';
    }

    function startGame() {
        startAudio();

        gameState = 'intro';
        gameRunning = true;
        score = 0;
        gameTime = 0;
        introStartTime = 0;
        difficultyLevel = 0;
        backgroundOffset = 0;
        grandstandTimer = 0;
        grandstandVisible = true;
        grandstandX = displayWidth; 
        grandstandSpeed = -displayWidth * 0.3; 
        nextGrandstandInterval = 15000 + Math.random() * 5000;

        if (isMobilePortrait) {
            obstacleSpawnRate = 2200; 
            obstacleSpeed = 600; 
        } else {
            obstacleSpawnRate = 1800;
            obstacleSpeed = 800;
        }

        player.y = groundY - player.height;
        player.velocityY = 0;
        player.grounded = true;
        player.isCharging = false;
        chargeStartTime = 0;

        maxCar.x = displayWidth * 0.225;
        maxCar.speed = 0;
        maxCar.visible = true;

        obstacles.length = 0;
        lastObstacleTime = 0;
        obstacleClusterChance = isMobilePortrait ? 0.2 : 0.3; 

        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('score').style.display = 'block';
        document.getElementById('speedIndicator').style.display = 'block';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('introText').style.display = 'block';

        lastObstacleTime = gameTime + 1000; 
        requestAnimationFrame(gameLoop);
    }

    function drawTrees(deltaTime) {
        if (treeImageLoaded && treeImage.complete) {
            const treeSpacing = Math.max(60, displayWidth * 0.02);
            const scrollSpeed = Math.max(300, displayWidth * 0.375);

            backgroundOffset += scrollSpeed * (deltaTime / 1000);
            const startX = -(backgroundOffset % treeSpacing);

            for (let i = startX - treeSpacing * 2; i < displayWidth + treeSpacing * 4; i += treeSpacing) {
                const treeSeed = Math.floor((i + backgroundOffset) / treeSpacing);

                const rand = Math.abs(Math.sin(treeSeed * 87.42)) % 1;
                const treeScale = 0.9 + rand * 1.4; 

                const baseTreeSize = Math.min(200, displayHeight * 3.5); 
                const treeWidth = baseTreeSize * treeScale;
                const treeHeight = baseTreeSize * treeScale;
                const treeY = groundY - treeHeight;

                ctx.drawImage(treeImage, i - treeWidth / 2, treeY, treeWidth, treeHeight);
            }
        }
    }
    
    function drawBackground(deltaTime) {
        const gradient = ctx.createLinearGradient(0, 0, 0, displayHeight);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.7, '#98FB98');
        gradient.addColorStop(1, '#228B22');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        drawTrees(deltaTime);

        if (grandstandVisible && grandstandImageLoaded) {
            const grandstandWidth = displayWidth * 0.6;
            const grandstandHeight = grandstandWidth * 0.4;
            const y = groundY - grandstandHeight - 10;
            ctx.drawImage(grandstandImage, grandstandX, y, grandstandWidth, grandstandHeight);
        }

        ctx.fillStyle = '#494241';
        ctx.fillRect(0, groundY, displayWidth, displayHeight - groundY);

        ctx.fillStyle = 'white';
        const roadLineSpacing = Math.max(80, displayWidth * 0.1);
        const roadScrollSpeed = Math.max(800, displayWidth);
        const roadOffset = ((gameTime * roadScrollSpeed) / 1000) % roadLineSpacing;

        for (let i = -roadOffset; i < displayWidth + 50; i += roadLineSpacing) {
            ctx.fillRect(i, groundY - 5, 40, 3);
        }
    }

    function updatePlayer(deltaTime) {
        player.velocityY += player.gravity * (deltaTime / 1000);
        player.y += player.velocityY * (deltaTime / 1000);

        const wasGrounded = player.grounded;
        if (player.y >= groundY - player.height) {
            player.y = groundY - player.height;
            player.velocityY = 0;
            player.grounded = true;

            if (!wasGrounded && wantsToCharge && !player.isCharging) {
                player.isCharging = true;
                chargeStartTime = gameTime;
            }
        } else {
            player.grounded = false;
        }
    }

    function updateMaxCar(deltaTime) {
        if (gameState === 'intro') {
            if (gameTime > 1000) {
                const accelerationPerSecond = displayWidth * 0.4;
                maxCar.speed += accelerationPerSecond * (deltaTime / 1000);
                maxCar.x += maxCar.speed * (deltaTime / 1000);
            }
            if (maxCar.x > displayWidth + player.width * 1.25) {
                maxCar.visible = false;
            }
            if (gameTime >= introDuration) {
                gameState = 'playing';
                lastObstacleTime = gameTime;
                document.getElementById('introText').style.display = 'none';
                document.getElementById('instructions').style.display = 'block';
            }
        }
    }

    function spawnObstacle(x) {
        const obstacleHeight = isMobilePortrait ? 22 : 26;
        const obstacleY = groundY - obstacleHeight;

        obstacles.push({
            x: x,
            y: obstacleY,
            width: isMobilePortrait ? 44 : 50,
            height: obstacleHeight,
            jumpedOver: false,
            quote: overtakeQuotes[Math.floor(Math.random() * overtakeQuotes.length)]
        });
    }

    function wrapText(ctx, text, maxWidth) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
                currentLine += ' ' + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    }

    function updateObstacles(deltaTime) {
        if (gameState !== 'playing') return;

        const newDifficultyLevel = Math.floor(score / (isMobilePortrait ? 4 : 3)); 

        if (newDifficultyLevel > difficultyLevel) {
            difficultyLevel = newDifficultyLevel;

            if (isMobilePortrait) {
                if (difficultyLevel <= 10) {
                    obstacleSpawnRate = Math.max(1200, 2200 - (difficultyLevel * 80));
                    obstacleSpeed = Math.min(1000, 600 + (difficultyLevel * 40));
                    minObstacleGap = Math.max(120, 140 - (difficultyLevel * 2));
                    obstacleClusterChance = Math.min(0.5, 0.2 + (difficultyLevel * 0.02));
                } else {
                    obstacleSpawnRate = Math.max(800, 1200 - ((difficultyLevel - 10) * 30));
                    obstacleSpeed = Math.min(1400, 1000 + ((difficultyLevel - 10) * 40));
                    minObstacleGap = Math.max(100, 120 - ((difficultyLevel - 10) * 2));
                    obstacleClusterChance = Math.min(0.7, 0.5 + ((difficultyLevel - 10) * 0.02));
                }
            } else {
                if (difficultyLevel <= 15) {
                    obstacleSpawnRate = Math.max(800, 1800 - (difficultyLevel * 80));
                    obstacleSpeed = Math.min(1400, 800 + (difficultyLevel * 60));
                    minObstacleGap = Math.max(90, Math.max(120, displayWidth * 0.15) - (difficultyLevel * 3));
                    obstacleClusterChance = Math.min(0.7, 0.3 + (difficultyLevel * 0.025));
                } else {
                    obstacleSpawnRate = Math.max(400, 800 - ((difficultyLevel - 15) * 40));
                    obstacleSpeed = Math.min(2000, 1400 + ((difficultyLevel - 15) * 80));
                    minObstacleGap = Math.max(70, 90 - ((difficultyLevel - 15) * 2));
                    obstacleClusterChance = Math.min(0.9, 0.7 + ((difficultyLevel - 15) * 0.02));
                }
            }
        }

        if (gameTime - lastObstacleTime >= obstacleSpawnRate) {
            const canSpawn = obstacles.length === 0 ||
                (displayWidth - obstacles[obstacles.length - 1].x) >= minObstacleGap;

            if (canSpawn) {
                const shouldCluster = Math.random() < obstacleClusterChance;

                if (shouldCluster && obstacles.length > 0) {
                    const clusterSize = 2 + Math.floor(Math.random() * (isMobilePortrait ? 2 : 3)); 
                    const clusterGap = Math.max(40, minObstacleGap * 0.4);

                    for (let i = 0; i < clusterSize; i++) {
                        const x = displayWidth + (i * clusterGap);
                        spawnObstacle(x);
                    }
                } else {
                    spawnObstacle(displayWidth);
                }

                lastObstacleTime = gameTime;
            }
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].x -= obstacleSpeed * (deltaTime / 1000);
            if (obstacles[i].x + obstacles[i].width < 0) {
                activeQuotes.push({
                    text: obstacles[i].quote,
                    x: Math.max(100, Math.min(player.x + player.width / 2, displayWidth - 100)),
                    y: player.y - 10,
                    alpha: 1,
                    floatSpeed: 20,
                    fadeSpeed: 0.5,
                    dx: Math.random() * 20 - 10
                });

                obstacles.splice(i, 1);
                score += 1;
            }

        }

        for (let i = activeQuotes.length - 1; i >= 0; i--) {
            const quote = activeQuotes[i];
            quote.x += quote.dx * (deltaTime / 1000);
            quote.y -= quote.floatSpeed * (deltaTime / 1000);
            quote.alpha -= quote.fadeSpeed * (deltaTime / 1000);

            if (quote.alpha <= 0) {
                activeQuotes.splice(i, 1);
                continue;
            }

            ctx.globalAlpha = Math.max(0, quote.alpha);
            ctx.font = '16px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;

            ctx.strokeText(quote.text, quote.x, quote.y);
            ctx.fillText(quote.text, quote.x, quote.y);
            ctx.globalAlpha = 1.0;
        }
    }

    function checkCollisions() {
        if (gameState !== 'playing') return;
        for (let obstacle of obstacles) {
            if (player.x < obstacle.x + obstacle.width &&
                player.x + player.width > obstacle.x &&
                player.y < obstacle.y + obstacle.height &&
                player.y + player.height > obstacle.y) {
                gameRunning = false;
                showGameOver();
                return;
            }
        }
    }

    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        deltaTimeAccumulator += deltaTime;

        while (deltaTimeAccumulator >= TARGET_FRAME_TIME) {
            gameTime += TARGET_FRAME_TIME;

            grandstandTimer += TARGET_FRAME_TIME;
            if (!grandstandVisible && grandstandTimer >= nextGrandstandInterval) {
                grandstandVisible = true;
                grandstandX = displayWidth;
                grandstandSpeed = -displayWidth * 0.3; 
                grandstandTimer = 0;
                nextGrandstandInterval = 15000 + Math.random() * 5000; 
            }

            if (grandstandVisible) {
                grandstandX += grandstandSpeed * (TARGET_FRAME_TIME / 1000);
                if (grandstandX < -displayWidth * 0.6) {
                    grandstandVisible = false;
                    grandstandTimer = 0;
                }
            }

            updatePlayer(TARGET_FRAME_TIME);
            updateMaxCar(TARGET_FRAME_TIME);
            updateObstacles(TARGET_FRAME_TIME);
            checkCollisions();

            deltaTimeAccumulator -= TARGET_FRAME_TIME;
        }

        // Render
        ctx.clearRect(0, 0, displayWidth, displayHeight);

        drawBackground(deltaTime);
        drawMcLaren(player.x, player.y);

        if (gameState === 'intro' && maxCar.visible) {
            drawMaxRedBull(maxCar.x, maxCar.y, maxCar.width, maxCar.height);
        }

        if (gameState === 'playing') {
            for (let obstacle of obstacles) {
                const obstacleInView = obstacle.x + obstacle.width > 0 && obstacle.x < displayWidth;
                const showWarning = isMobilePortrait && obstacleInView &&
                    obstacle.x > displayWidth - warningZone && obstacle.x < displayWidth;
                const showPerfectZone = isMobilePortrait && obstacleInView &&
                    obstacle.x > displayWidth - perfectJumpZone &&
                    obstacle.x < displayWidth - perfectJumpZone + 50;

                drawRedBull(obstacle.x, obstacle.y, obstacle.width, obstacle.height, showWarning, showPerfectZone);
            }

            for (let i = activeQuotes.length - 1; i >= 0; i--) {
                const quote = activeQuotes[i];
                quote.x += quote.dx * (deltaTime / 1000);
                quote.y -= quote.floatSpeed * (deltaTime / 1000);
                quote.alpha -= quote.fadeSpeed * (deltaTime / 1000);

                if (quote.alpha <= 0) {
                    activeQuotes.splice(i, 1);
                    continue;
                }

                ctx.globalAlpha = Math.max(0, quote.alpha);
                ctx.font = '16px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;

                ctx.strokeText(quote.text, quote.x, quote.y);
                ctx.fillText(quote.text, quote.x, quote.y);
                ctx.globalAlpha = 1.0;
            }
        }

        // Update UI
        document.getElementById('score').textContent = `Championship points: ${score}`;
        const speedKmh = Math.round((obstacleSpeed / 1000) * 3.6 * 10); 
        document.getElementById('speedIndicator').textContent = `Speed: ${speedKmh} km/h`;

        requestAnimationFrame(gameLoop);
    }

    function showGameOver() {
        gameState = 'gameOver';
        gameRunning = false;
        document.getElementById('finalScore').textContent = `Final Score: ${score}`;

        const nameInput = document.getElementById('playerNameInput');
        nameInput.value = '';
        nameInput.disabled = false;

        renderHighScores();

        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('speedIndicator').style.display = 'none';
    }

    function restartGame() {
        startGame();
    }

    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            startCharging();
        }
        if (!audioInitialized && !isAudioMuted) {
            initializeAudio();
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            executeJump();
            stopCharging();
        }
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            startCharging();
        }
        if (!audioInitialized && !isAudioMuted) {
            initializeAudio();
        }
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            executeJump();
            stopCharging();
        }
    });

    document.addEventListener('touchstart', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !isInputDown) {
            e.preventDefault();
            if (gameState === 'playing') {
                isInputDown = true;
                startCharging();
            }
            if (!audioInitialized && !isAudioMuted) {
                initializeAudio();
            }
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && isInputDown) {
            e.preventDefault();
            if (gameState === 'playing') {
                isInputDown = false;
                executeJump();
                stopCharging();
            }
        }
    });

    window.addEventListener('resize', () => {
        clearTimeout(window.resizeTimeout);
        window.resizeTimeout = setTimeout(() => {
            devicePixelRatio = window.devicePixelRatio || 1;
            resizeCanvas();
        }, 100);
    });

    backgroundMusic.addEventListener('canplaythrough', () => {
        console.log('Audio is ready to play');
    });

    backgroundMusic.addEventListener('error', (e) => {
        console.log('Audio loading error:', e);
    });

    resizeCanvas();
    updateGameDimensions();
    player.y = groundY - player.height;
    player.grounded = true;
    showMainMenu();
</script>
</body>
</html>