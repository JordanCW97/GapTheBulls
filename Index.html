<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gap The Bulls!</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
            overflow: hidden;
            border: 3px solid #ff6600;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
            touch-action: none;
        }

        .ui {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #score {
            top: 20px;
            left: 70px;
            font-size: 24px;
        }

        #speedIndicator {
            top: 20px;
            right: 20px;
            font-size: 18px;
            text-align: right;
        }

        #audioToggle {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ff6600;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            transition: all 0.3s ease;
            z-index: 15;
            user-select: none;
            touch-action: manipulation;
        }

        #audioToggle:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        #audioToggle.muted {
            color: #ff6666;
            border-color: #ff6666;
        }

        #instructions {
            top: 60px;
            right: 20px;
            font-size: 14px;
            text-align: right;
        }

        #introText {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
        }

        #mainMenu, #howToPlay, #credits {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 30;
            border: 2px solid #ff6600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
        }

        #mainMenu {
            display: flex;
        }

        #howToPlay, #credits {
            display: none;
            flex-direction: column;
            max-width: 90vw;
            width: 800px;
            max-height: 95vh; /* Limit modal height to 80% of viewport */
            overflow-y: auto;  /* Enable vertical scroll if content exceeds height */
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            #howToPlay, #credits {
                width: 90vw;
                max-height: 85vh;
                padding: 20px;
                overflow-y: auto;
            }
        }

        .menu-center {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .driver-image {
            width: 120px;
            height: auto;
            opacity: 0.9;
        }

        .driver-image.lando {
            align-self: flex-start;
        }

        .driver-image.max {
            align-self: flex-end;
        }

        .menu-title {
            color: #ff6600;
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .menu-button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: background 0.3s;
            display: block;
            width: 200px;
            margin: 10px auto;
            touch-action: manipulation;
        }

        .menu-button:hover {
            background: #e55a00;
        }

        .back-button {
            background: #666;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
        }

        .back-button:hover {
            background: #555;
        }

        .menu-content {
            color: white;
            line-height: 1.6;
            text-align: left;
            max-width: 400px;
        }

        .menu-content h3 {
            color: #ff6600;
            text-align: center;
        }

        #gameOver h2 {
            color: #ff6600;
            margin-top: 0;
            font-size: 28px;
        }
        #gameOver p {
            color: #ffffff;
        }

        #gameOver button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: background 0.3s;
            touch-action: manipulation;
        }

        #gameOver button:hover {
            background: #e55a00;
        }

        .road-line {
            position: absolute;
            width: 60px;
            height: 4px;
            background: white;
            bottom: 150px;
            animation: roadMove 1s linear infinite;
        }

        @keyframes roadMove {
            from { right: -60px; }
            to { right: 100%; }
        }

        /* Mobile Portrait Optimizations */
        @media (max-width: 768px) and (orientation: portrait) {
            #gameContainer {
                border: none;
                max-width: none;
                max-height: none;
                border-radius: 0;
            }

            #score {
                font-size: 16px;
                left: 65px;
                top: 15px;
            }

            #speedIndicator {
                font-size: 14px;
                top: 15px;
            }

            #instructions {
                font-size: 12px;
                top: 50px;
            }

            #gameOver h2 {
                font-size: 24px;
            }

            #gameOver button {
                font-size: 16px;
                padding: 10px 20px;
            }

            #audioToggle {
                width: 35px;
                height: 35px;
                font-size: 18px;
                top: 15px;
                left: 15px;
            }

            .menu-title {
                font-size: 28px;
            }

            .driver-image {
                width: 80px;
            }

            #mainMenu, #howToPlay, #credits {
                padding: 20px;
                gap: 20px;
            }
        }

        @media (max-width: 480px) {
            .menu-title {
                font-size: 24px;
            }

            .menu-button {
                font-size: 16px;
                padding: 12px 24px;
                width: 150px;
            }

            .driver-image {
                width: 60px;
            }
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- Audio Toggle Button -->
    <div id="audioToggle" onclick="toggleAudio()" title="Toggle Audio">🔊</div>

    <div id="score" class="ui">Championship points: 0</div>
    <div id="speedIndicator" class="ui">Speed: 0 km/h</div>
    <div id="instructions" class="ui">
        Hold to Jump Higher<br>
    </div>

    <div id="introText" class="ui">
        Max is pulling away!
    </div>

    <div id="mainMenu">
        <img id="landoImg" class="driver-image lando" style="display: none;">
        <div class="menu-center">
            <h1 class="menu-title">Gap The Bulls</h1>
            <button class="menu-button" onclick="startGame()">Play</button>
            <button class="menu-button" onclick="showHowToPlay()">How to Play</button>
            <button class="menu-button" onclick="showCredits()">Credits</button>
        </div>
        <img id="maxImg" class="driver-image max" style="display: none;">
    </div>

    <div id="howToPlay">
        <h1 class="menu-title">How to Play</h1>
        <div class="menu-content">
            <h3>Objective:</h3>
            <p>Help McLaren gap the Red Bull second drivers, but you'll never quite catch Max Verstappen!</p>

            <h3>Controls:</h3>
            <p>• Hold Click/Tap for higher jumps</p>
            <p>• Quick tap for small hops</p>
            <p>• Watch the charge bar above your car!</p>

            <h3>Mobile Tips:</h3>
            <p>• Look for red warning indicators showing incoming obstacles</p>
            <p>• Yellow zones indicate perfect jump timing</p>
            <p>• Speed indicator helps you anticipate difficulty</p>

            <h3>Gameplay:</h3>
            <p>• Jump over Red Bull cars to earn championship points</p>
            <p>• The game gets faster and more challenging as you progress</p>
            <p>• Watch out for obstacle clusters!</p>
            <p>• Don't crash into the Red Bull cars!</p>
        </div>
        <button class="menu-button back-button" onclick="showMainMenu()">Back</button>
    </div>

    <div id="credits">
        <h1 class="menu-title">Credits</h1>
        <div class="menu-content">
            <h3>Game Development:</h3>
            <p>Jordan Carter-Wightwick</p>

            <h3>Inspired by:</h3>
            <p>Charlotte's poor choice in F1 teams.</p>

            <h3>Special Thanks:</h3>
            <p>To all F1 fans who know the pain of watching Max dominate the sport!</p>

            <h3>Remember:</h3>
            <p>"It's lights out and away we go!" 🏁</p>
        </div>
        <button class="menu-button back-button" onclick="showMainMenu()">Back</button>
    </div>

    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Oops! Max made McLaren look bad again!</p>
        <p id="finalScore">Final Score: 0</p>
        <button onclick="restartGame()">Try Again</button>
        <button class="back-button" onclick="showMainMenu()" style="margin-left: 10px;">Main Menu</button>
    </div>

    <!-- Audio Element -->
    <audio id="backgroundMusic" loop>
        <source src="./Resources/Audio/theme.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Device pixel ratio for sharp rendering on high-DPI displays
    let devicePixelRatio = window.devicePixelRatio || 1;
    let displayWidth, displayHeight;
    let canvasWidth, canvasHeight;
    let isMobilePortrait = false;

    // Audio setup
    const backgroundMusic = document.getElementById('backgroundMusic');
    const audioToggle = document.getElementById('audioToggle');
    let isAudioMuted = false;
    let audioInitialized = false;

    // Set initial volume
    backgroundMusic.volume = 0.3;

    // Frame rate management
    const TARGET_FPS = 60;
    const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
    let lastFrameTime = 0;
    let deltaTimeAccumulator = 0;

    // Check if device is mobile in portrait mode
    function checkMobilePortrait() {
        isMobilePortrait = window.innerWidth < 768 && window.innerHeight > window.innerWidth;
        return isMobilePortrait;
    }

    // Function to initialize and start audio
    function initializeAudio() {
        if (!audioInitialized && !isAudioMuted) {
            backgroundMusic.play().then(() => {
                audioInitialized = true;
                console.log('Audio initialized and playing successfully');
            }).catch(error => {
                console.log('Audio initialization failed:', error);
            });
        }
    }

    function startAudio() {
        if (!isAudioMuted) {
            if (!audioInitialized) {
                initializeAudio();
            } else {
                backgroundMusic.play().catch(error => {
                    console.log('Failed to play audio:', error);
                });
            }
        }
    }

    function toggleAudio() {
        if (!audioInitialized) {
            initializeAudio();
        }

        isAudioMuted = !isAudioMuted;

        if (isAudioMuted) {
            backgroundMusic.pause();
            audioToggle.textContent = '🔇';
            audioToggle.classList.add('muted');
            audioToggle.title = 'Unmute Audio';
        } else {
            backgroundMusic.play().catch(error => {
                console.log('Failed to play audio:', error);
            });
            audioToggle.textContent = '🔊';
            audioToggle.classList.remove('muted');
            audioToggle.title = 'Mute Audio';
        }
    }

    // Set canvas size with proper scaling
    function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        const containerRect = container.getBoundingClientRect();

        displayWidth = containerRect.width;
        displayHeight = containerRect.height;

        checkMobilePortrait();

        canvasWidth = displayWidth * devicePixelRatio;
        canvasHeight = displayHeight * devicePixelRatio;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';

        ctx.scale(devicePixelRatio, devicePixelRatio);

        updateGameDimensions();
    }

    // Game state
    let gameState = 'menu';
    let gameRunning = false;
    let score = 0;
    let gameTime = 0;
    let introStartTime = 0;
    const introDuration = 3000;

    // Background scrolling offset
    let backgroundOffset = 0;

    // Input tracking
    let isInputDown = false;
    let chargeStartTime = 0;
    let wantsToCharge = false;

    // Player with adaptive positioning for mobile
    const player = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        velocityY: 0,
        grounded: false,
        minJumpPower: -300,
        maxJumpPower: -700,
        gravity: 1600,
        isCharging: false,
        chargeTime: 0,
        maxChargeTime: 300
    };

    const maxCar = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        speed: 0,
        visible: false
    };

    // Enhanced obstacle system with mobile optimizations
    const obstacles = [];
    let obstacleSpawnRate = 1800;
    let obstacleSpeed = 800;
    let minObstacleGap = 0;
    let lastObstacleTime = 0;
    let difficultyLevel = 0;
    let obstacleClusterChance = 0.3;

    // Mobile optimization variables
    let warningZone = 0; // Distance from right edge to show warnings
    let perfectJumpZone = 0; // Distance for perfect jump timing indicators

    // Ground level
    let groundY;

    function updateGameDimensions() {
        // Adaptive player positioning for mobile portrait
        if (isMobilePortrait) {
            player.width = Math.min(60, displayWidth * 0.12);
            player.height = Math.min(30, displayHeight * 0.04);
            player.x = displayWidth * 0.2; // Move player more to the left for better visibility

            // Increase warning and perfect jump zones for mobile
            warningZone = displayWidth * 0.6; // Warn when obstacles are 60% across screen
            perfectJumpZone = displayWidth * 0.4; // Perfect timing at 40% across screen

            // Slower initial speeds for mobile
            obstacleSpeed = Math.max(600, obstacleSpeed * 0.8);
            obstacleSpawnRate = Math.max(2000, obstacleSpawnRate * 1.2);
        } else {
            player.width = Math.min(80, displayWidth * 0.1);
            player.height = Math.min(40, displayHeight * 0.067);
            player.x = displayWidth * 0.125;

            warningZone = displayWidth * 0.4;
            perfectJumpZone = displayWidth * 0.25;
        }

        maxCar.width = player.width;
        maxCar.height = player.height;
        maxCar.x = displayWidth * 0.225;

        groundY = displayHeight - Math.min(100, displayHeight * 0.167);
        minObstacleGap = Math.max(isMobilePortrait ? 140 : 120, displayWidth * 0.15);

        if (!player.grounded) {
        } else {
            player.y = groundY - player.height;
        }
        maxCar.y = groundY - maxCar.height;
    }

    // Image loading
    const treeImage = new Image();
    let treeImageLoaded = false;
    treeImage.onload = function() { treeImageLoaded = true; };
    treeImage.onerror = function() { treeImageLoaded = false; };
    treeImage.src = './Resources/Sprites/tree_cartoon_med.png';

    const mclarenImage = new Image();
    const redBullImage = new Image();
    let mclarenImageLoaded = false;
    let redBullImageLoaded = false;
    mclarenImage.onload = function() { mclarenImageLoaded = true; };
    mclarenImage.onerror = function() { mclarenImageLoaded = false; };
    redBullImage.onload = function() { redBullImageLoaded = true; };
    redBullImage.onerror = function() { redBullImageLoaded = false; };
    mclarenImage.src = './Resources/Sprites/MCL.png';
    redBullImage.src = './Resources/Sprites/RB.png';

    const landoImage = new Image();
    const maxImage = new Image();
    let landoImageLoaded = false;
    let maxImageLoaded = false;
    landoImage.onload = function() { landoImageLoaded = true; updateDriverImages(); };
    landoImage.onerror = function() { landoImageLoaded = false; };
    maxImage.onload = function() { maxImageLoaded = true; updateDriverImages(); };
    maxImage.onerror = function() { maxImageLoaded = false; };
    landoImage.src = './Resources/Sprites/Lando.png';
    maxImage.src = './Resources/Sprites/Max.png';

    function updateDriverImages() {
        if (gameState === 'menu') {
            if (landoImageLoaded) {
                const landoImg = document.getElementById('landoImg');
                landoImg.src = landoImage.src;
                landoImg.style.display = 'block';
            }
            if (maxImageLoaded) {
                const maxImg = document.getElementById('maxImg');
                maxImg.src = maxImage.src;
                maxImg.style.display = 'block';
            }
        }
    }

    function startCharging() {
        wantsToCharge = true;
        if (player.grounded && !player.isCharging) {
            player.isCharging = true;
            chargeStartTime = gameTime;
        }
    }

    function stopCharging() {
        wantsToCharge = false;
        player.isCharging = false;
        chargeStartTime = 0;
    }

    function executeJump() {
        if (player.isCharging && player.grounded) {
            const chargeTime = gameTime - chargeStartTime;
            const chargeRatio = Math.min(chargeTime / player.maxChargeTime, 1);
            const jumpPower = player.minJumpPower + (player.maxJumpPower - player.minJumpPower) * chargeRatio;

            player.velocityY = jumpPower;
            player.grounded = false;
            player.isCharging = false;
            chargeStartTime = 0;

            if (player.y >= groundY - player.height) {
                player.y = groundY - player.height - 1;
            }
        }
    }

    // Enhanced drawing functions with mobile indicators
    function drawMcLaren(x, y) {
        if (mclarenImageLoaded && mclarenImage.complete) {
            const spriteAspectRatio = mclarenImage.width / mclarenImage.height;
            const scaledWidth = player.height * spriteAspectRatio;
            ctx.drawImage(mclarenImage, x, y, scaledWidth, player.height);
        } else {
            // Fallback drawing
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(x, y, player.width, player.height);
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + player.width * 0.0625, y + player.height * 0.125, player.width * 0.1875, player.height * 0.2);
            ctx.fillRect(x + player.width * 0.75, y + player.height * 0.125, player.width * 0.1875, player.height * 0.2);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = player.height * 0.2;
            ctx.arc(x + player.width * 0.1875, y + player.height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + player.width * 0.8125, y + player.height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = `${player.height * 0.3}px Arial`;
            ctx.fillText('MCL', x + player.width * 0.3125, y + player.height * 0.625);
        }

        // Enhanced charge indicator
        if ((player.isCharging && (player.grounded || player.velocityY >= 0)) ||
            (wantsToCharge && !player.grounded)) {
            const chargeRatio = player.isCharging ?
                Math.min((gameTime - chargeStartTime) / player.maxChargeTime, 1) : 0;
            const barWidth = isMobilePortrait ? 50 : 60;
            const barHeight = isMobilePortrait ? 5 : 6;
            const barX = x + (player.width - barWidth) / 2;
            const barY = y - (isMobilePortrait ? 12 : 15);

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Charge bar
            if (player.isCharging) {
                const chargeWidth = barWidth * chargeRatio;
                if (chargeRatio < 0.5) {
                    ctx.fillStyle = '#00ff00';
                } else if (chargeRatio < 0.8) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                ctx.fillRect(barX, barY, chargeWidth, barHeight);
            } else if (wantsToCharge) {
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(barX, barY, barWidth * 0.1, barHeight);
            }

            // Border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }

    function drawRedBull(x, y, width, height, showWarning = false, showPerfectZone = false) {
        // Draw the car
        if (redBullImageLoaded && redBullImage.complete) {
            const spriteAspectRatio = redBullImage.width / redBullImage.height;
            const scaledWidth = height * spriteAspectRatio;
            ctx.drawImage(redBullImage, x, y, scaledWidth, height);
        } else {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(x + width * 0.0714, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillRect(x + width * 0.7571, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = height * 0.15;
            ctx.arc(x + width * 0.1714, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + width * 0.8286, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = `${height * 0.25}px Arial`;
            const textWidth = ctx.measureText('RB').width;
            ctx.fillText('RB', x + (width - textWidth) / 2, y + height * 0.625);
        }
    }

    function drawMaxRedBull(x, y, width, height) {
        if (redBullImageLoaded && redBullImage.complete) {
            const spriteAspectRatio = redBullImage.width / redBullImage.height;
            const scaledWidth = height * spriteAspectRatio;
            ctx.drawImage(redBullImage, x, y, scaledWidth, height);
        } else {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x + width * 0.0714, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillRect(x + width * 0.7571, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = height * 0.15;
            ctx.arc(x + width * 0.1714, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + width * 0.8286, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.font = `${height * 0.25}px Arial`;
            const textWidth = ctx.measureText('MV').width;
            ctx.fillText('MV', x + (width - textWidth) / 2, y + height * 0.625);
        }
    }

    // Menu functions
    function showMainMenu() {
        gameState = 'menu';
        gameRunning = false;
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('howToPlay').style.display = 'none';
        document.getElementById('credits').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('score').style.display = 'none';
        document.getElementById('speedIndicator').style.display = 'none';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('introText').style.display = 'none';
        updateDriverImages();
    }

    function showHowToPlay() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('howToPlay').style.display = 'block';
    }

    function showCredits() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('credits').style.display = 'block';
    }

    function startGame() {
        startAudio();

        gameState = 'intro';
        gameRunning = true;
        score = 0;
        gameTime = 0;
        introStartTime = 0;
        difficultyLevel = 0;
        backgroundOffset = 0;

        // Reset mobile-optimized speeds
        if (isMobilePortrait) {
            obstacleSpawnRate = 2200; // Slower spawn for mobile
            obstacleSpeed = 600; // Slower initial speed for mobile
        } else {
            obstacleSpawnRate = 1800;
            obstacleSpeed = 800;
        }

        player.y = groundY - player.height;
        player.velocityY = 0;
        player.grounded = true;
        player.isCharging = false;
        chargeStartTime = 0;

        maxCar.x = displayWidth * 0.225;
        maxCar.speed = 0;
        maxCar.visible = true;

        obstacles.length = 0;
        lastObstacleTime = 0;
        obstacleClusterChance = isMobilePortrait ? 0.2 : 0.3; // Fewer clusters on mobile

        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('score').style.display = 'block';
        document.getElementById('speedIndicator').style.display = 'block';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('introText').style.display = 'block';

        requestAnimationFrame(gameLoop);
    }

    function drawTrees(deltaTime) {
        if (treeImageLoaded && treeImage.complete) {
            const treeSpacing = Math.max(60, displayWidth * 0.02);
            const scrollSpeed = Math.max(300, displayWidth * 0.375);

            backgroundOffset += scrollSpeed * (deltaTime / 1000);
            const startX = -(backgroundOffset % treeSpacing);

            for (let i = startX - treeSpacing * 2; i < displayWidth + treeSpacing * 4; i += treeSpacing) {
                const treeSeed = Math.floor((i + backgroundOffset) / treeSpacing);

                // More variation, slightly smaller overall scale
                const rand = Math.abs(Math.sin(treeSeed * 87.42)) % 1;
                const treeScale = 0.9 + rand * 1.4; // Range: 0.9 to 2.3

                const baseTreeSize = Math.min(200, displayHeight * 3.5); // Slightly smaller base
                const treeWidth = baseTreeSize * treeScale;
                const treeHeight = baseTreeSize * treeScale;
                const treeY = groundY - treeHeight;

                ctx.drawImage(treeImage, i - treeWidth / 2, treeY, treeWidth, treeHeight);
            }
        }
    }
    
    function drawBackground(deltaTime) {
        const gradient = ctx.createLinearGradient(0, 0, 0, displayHeight);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.7, '#98FB98');
        gradient.addColorStop(1, '#228B22');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        drawTrees(deltaTime);

        ctx.fillStyle = '#494241';
        ctx.fillRect(0, groundY, displayWidth, displayHeight - groundY);

        // Road lines
        ctx.fillStyle = 'white';
        const roadLineSpacing = Math.max(80, displayWidth * 0.1);
        const roadScrollSpeed = Math.max(800, displayWidth);
        const roadOffset = ((gameTime * roadScrollSpeed) / 1000) % roadLineSpacing;

        for (let i = -roadOffset; i < displayWidth + 50; i += roadLineSpacing) {
            ctx.fillRect(i, groundY - 5, 40, 3);
        }
    }

    function updatePlayer(deltaTime) {
        player.velocityY += player.gravity * (deltaTime / 1000);
        player.y += player.velocityY * (deltaTime / 1000);

        const wasGrounded = player.grounded;
        if (player.y >= groundY - player.height) {
            player.y = groundY - player.height;
            player.velocityY = 0;
            player.grounded = true;

            if (!wasGrounded && wantsToCharge && !player.isCharging) {
                player.isCharging = true;
                chargeStartTime = gameTime;
            }
        } else {
            player.grounded = false;
        }
    }

    function updateMaxCar(deltaTime) {
        if (gameState === 'intro') {
            if (gameTime > 1000) {
                const accelerationPerSecond = displayWidth * 0.4;
                maxCar.speed += accelerationPerSecond * (deltaTime / 1000);
                maxCar.x += maxCar.speed * (deltaTime / 1000);
            }
            if (maxCar.x > displayWidth + player.width * 1.25) {
                maxCar.visible = false;
            }
            if (gameTime >= introDuration) {
                gameState = 'playing';
                lastObstacleTime = gameTime;
                document.getElementById('introText').style.display = 'none';
                document.getElementById('instructions').style.display = 'block';
            }
        }
    }

    function spawnObstacle(x) {
        const obstacleHeight = isMobilePortrait ? 32 : 35;
        const obstacleY = groundY - obstacleHeight;

        obstacles.push({
            x: x,
            y: obstacleY,
            width: isMobilePortrait ? 65 : 70,
            height: obstacleHeight
        });
    }

    function updateObstacles(deltaTime) {
        if (gameState !== 'playing') return;

        const newDifficultyLevel = Math.floor(score / (isMobilePortrait ? 4 : 3)); // Slower progression on mobile

        if (newDifficultyLevel > difficultyLevel) {
            difficultyLevel = newDifficultyLevel;

            if (isMobilePortrait) {
                // More conservative mobile difficulty scaling
                if (difficultyLevel <= 10) {
                    obstacleSpawnRate = Math.max(1200, 2200 - (difficultyLevel * 80));
                    obstacleSpeed = Math.min(1000, 600 + (difficultyLevel * 40));
                    minObstacleGap = Math.max(120, 140 - (difficultyLevel * 2));
                    obstacleClusterChance = Math.min(0.5, 0.2 + (difficultyLevel * 0.02));
                } else {
                    obstacleSpawnRate = Math.max(800, 1200 - ((difficultyLevel - 10) * 30));
                    obstacleSpeed = Math.min(1400, 1000 + ((difficultyLevel - 10) * 40));
                    minObstacleGap = Math.max(100, 120 - ((difficultyLevel - 10) * 2));
                    obstacleClusterChance = Math.min(0.7, 0.5 + ((difficultyLevel - 10) * 0.02));
                }
            } else {
                // Original desktop difficulty scaling
                if (difficultyLevel <= 15) {
                    obstacleSpawnRate = Math.max(800, 1800 - (difficultyLevel * 80));
                    obstacleSpeed = Math.min(1400, 800 + (difficultyLevel * 60));
                    minObstacleGap = Math.max(90, Math.max(120, displayWidth * 0.15) - (difficultyLevel * 3));
                    obstacleClusterChance = Math.min(0.7, 0.3 + (difficultyLevel * 0.025));
                } else {
                    obstacleSpawnRate = Math.max(400, 800 - ((difficultyLevel - 15) * 40));
                    obstacleSpeed = Math.min(2000, 1400 + ((difficultyLevel - 15) * 80));
                    minObstacleGap = Math.max(70, 90 - ((difficultyLevel - 15) * 2));
                    obstacleClusterChance = Math.min(0.9, 0.7 + ((difficultyLevel - 15) * 0.02));
                }
            }
        }

        // Spawn obstacles
        if (gameTime - lastObstacleTime >= obstacleSpawnRate) {
            const canSpawn = obstacles.length === 0 ||
                (displayWidth - obstacles[obstacles.length - 1].x) >= minObstacleGap;

            if (canSpawn) {
                const shouldCluster = Math.random() < obstacleClusterChance;

                if (shouldCluster && obstacles.length > 0) {
                    const clusterSize = 2 + Math.floor(Math.random() * (isMobilePortrait ? 2 : 3)); // Smaller clusters on mobile
                    const clusterGap = Math.max(40, minObstacleGap * 0.4);

                    for (let i = 0; i < clusterSize; i++) {
                        const x = displayWidth + (i * clusterGap);
                        spawnObstacle(x);
                    }
                } else {
                    spawnObstacle(displayWidth);
                }

                lastObstacleTime = gameTime;
            }
        }

        // Move obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].x -= obstacleSpeed * (deltaTime / 1000);
            if (obstacles[i].x + obstacles[i].width < 0) {
                obstacles.splice(i, 1);
                score += 1;
            }
        }
    }

    function checkCollisions() {
        if (gameState !== 'playing') return;
        for (let obstacle of obstacles) {
            if (player.x < obstacle.x + obstacle.width &&
                player.x + player.width > obstacle.x &&
                player.y < obstacle.y + obstacle.height &&
                player.y + player.height > obstacle.y) {
                gameRunning = false;
                showGameOver();
                return;
            }
        }
    }

    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        deltaTimeAccumulator += deltaTime;

        while (deltaTimeAccumulator >= TARGET_FRAME_TIME) {
            gameTime += TARGET_FRAME_TIME;

            updatePlayer(TARGET_FRAME_TIME);
            updateMaxCar(TARGET_FRAME_TIME);
            updateObstacles(TARGET_FRAME_TIME);
            checkCollisions();

            deltaTimeAccumulator -= TARGET_FRAME_TIME;
        }

        // Render
        ctx.clearRect(0, 0, displayWidth, displayHeight);

        drawBackground(deltaTime);
        drawMcLaren(player.x, player.y);

        if (gameState === 'intro' && maxCar.visible) {
            drawMaxRedBull(maxCar.x, maxCar.y, maxCar.width, maxCar.height);
        }

        if (gameState === 'playing') {
            for (let obstacle of obstacles) {
                // More precise warning zone detection to prevent off-screen drawing
                const obstacleInView = obstacle.x + obstacle.width > 0 && obstacle.x < displayWidth;
                const showWarning = isMobilePortrait && obstacleInView &&
                    obstacle.x > displayWidth - warningZone && obstacle.x < displayWidth;
                const showPerfectZone = isMobilePortrait && obstacleInView &&
                    obstacle.x > displayWidth - perfectJumpZone &&
                    obstacle.x < displayWidth - perfectJumpZone + 50;

                drawRedBull(obstacle.x, obstacle.y, obstacle.width, obstacle.height, showWarning, showPerfectZone);
            }
        }

        // Update UI
        document.getElementById('score').textContent = `Championship points: ${score}`;
        const speedKmh = Math.round((obstacleSpeed / 1000) * 3.6 * 10); // Convert to approximate km/h
        document.getElementById('speedIndicator').textContent = `Speed: ${speedKmh} km/h`;

        requestAnimationFrame(gameLoop);
    }

    function showGameOver() {
        gameState = 'gameOver';
        gameRunning = false;
        document.getElementById('finalScore').textContent = `Final Score: ${score}`;
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('speedIndicator').style.display = 'none';
    }

    function restartGame() {
        startGame();
    }

    // Enhanced event listeners
    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            startCharging();
        }
        if (!audioInitialized && !isAudioMuted) {
            initializeAudio();
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            executeJump();
            stopCharging();
        }
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            startCharging();
        }
        if (!audioInitialized && !isAudioMuted) {
            initializeAudio();
        }
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            executeJump();
            stopCharging();
        }
    });

    // Prevent touch scrolling and zooming
    document.addEventListener('touchstart', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !isInputDown) {
            e.preventDefault();
            if (gameState === 'playing') {
                isInputDown = true;
                startCharging();
            }
            if (!audioInitialized && !isAudioMuted) {
                initializeAudio();
            }
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && isInputDown) {
            e.preventDefault();
            if (gameState === 'playing') {
                isInputDown = false;
                executeJump();
                stopCharging();
            }
        }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
        clearTimeout(window.resizeTimeout);
        window.resizeTimeout = setTimeout(() => {
            devicePixelRatio = window.devicePixelRatio || 1;
            resizeCanvas();
        }, 100);
    });

    // Audio event listeners
    backgroundMusic.addEventListener('canplaythrough', () => {
        console.log('Audio is ready to play');
    });

    backgroundMusic.addEventListener('error', (e) => {
        console.log('Audio loading error:', e);
    });

    // Initialize canvas and start with main menu
    resizeCanvas();
    updateGameDimensions();
    player.y = groundY - player.height;
    player.grounded = true;
    showMainMenu();
</script>
</body>
</html>