<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>McLaren vs Red Bull Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
            overflow: hidden;
            border: 3px solid #ff6600;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
            touch-action: none;
        }

        .ui {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #score {
            top: 20px;
            left: 70px;
            font-size: 24px;
        }

        #audioToggle {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ff6600;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            transition: all 0.3s ease;
            z-index: 15;
            user-select: none;
            touch-action: manipulation;
        }

        #audioToggle:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        #audioToggle.muted {
            color: #ff6666;
            border-color: #ff6666;
        }

        #instructions {
            top: 20px;
            right: 20px;
            font-size: 16px;
            text-align: right;
        }

        #introText {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
        }

        #mainMenu, #howToPlay, #credits {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 30;
            border: 2px solid #ff6600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
        }

        #mainMenu {
            display: flex;
        }

        #howToPlay, #credits {
            display: none;
            flex-direction: column;
        }

        .menu-center {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .driver-image {
            width: 120px;
            height: auto;
            opacity: 0.9;
        }

        .driver-image.lando {
            align-self: flex-start;
        }

        .driver-image.max {
            align-self: flex-end;
        }

        .menu-title {
            color: #ff6600;
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .menu-button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: background 0.3s;
            display: block;
            width: 200px;
            margin: 10px auto;
            touch-action: manipulation;
        }

        .menu-button:hover {
            background: #e55a00;
        }

        .back-button {
            background: #666;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
        }

        .back-button:hover {
            background: #555;
        }

        .menu-content {
            color: white;
            line-height: 1.6;
            text-align: left;
            max-width: 400px;
        }

        .menu-content h3 {
            color: #ff6600;
            text-align: center;
        }

        #gameOver h2 {
            color: #ff6600;
            margin-top: 0;
            font-size: 28px;
        }
        #gameOver p {
            color: #ffffff;
        }

        #gameOver button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: background 0.3s;
            touch-action: manipulation;
        }

        #gameOver button:hover {
            background: #e55a00;
        }

        .road-line {
            position: absolute;
            width: 60px;
            height: 4px;
            background: white;
            bottom: 150px;
            animation: roadMove 1s linear infinite;
        }

        @keyframes roadMove {
            from { right: -60px; }
            to { right: 100%; }
        }

        @media (max-width: 768px) {
            #gameContainer {
                border: none;
                max-width: none;
                max-height: none;
                border-radius: 0;
            }

            #score, #instructions {
                font-size: 18px;
            }

            #gameOver h2 {
                font-size: 24px;
            }

            #gameOver button {
                font-size: 16px;
                padding: 10px 20px;
            }

            #audioToggle {
                width: 35px;
                height: 35px;
                font-size: 18px;
            }

            #score {
                left: 65px;
                font-size: 20px;
            }

            .menu-title {
                font-size: 28px;
            }

            .driver-image {
                width: 80px;
            }

            #mainMenu, #howToPlay, #credits {
                padding: 20px;
                gap: 20px;
            }
        }

        @media (max-width: 480px) {
            .menu-title {
                font-size: 24px;
            }

            .menu-button {
                font-size: 16px;
                padding: 12px 24px;
                width: 150px;
            }

            .driver-image {
                width: 60px;
            }
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- Audio Toggle Button -->
    <div id="audioToggle" onclick="toggleAudio()" title="Toggle Audio">üîä</div>

    <div id="score" class="ui">Championship points: 0</div>
    <div id="instructions" class="ui">
        Hold to Jump Higher<br>
        Gap the Red Bull second drivers<br>
        but never quite catch Max!
    </div>

    <div id="introText" class="ui">
        Max is pulling away!
    </div>

    <div id="mainMenu">
        <img id="landoImg" class="driver-image lando" style="display: none;">
        <div class="menu-center">
            <h1 class="menu-title">Gap The Bulls</h1>
            <button class="menu-button" onclick="startGame()">Play</button>
            <button class="menu-button" onclick="showHowToPlay()">How to Play</button>
            <button class="menu-button" onclick="showCredits()">Credits</button>
        </div>
        <img id="maxImg" class="driver-image max" style="display: none;">
    </div>

    <div id="howToPlay">
        <h1 class="menu-title">How to Play</h1>
        <div class="menu-content">
            <h3>Objective:</h3>
            <p>Help McLaren gap the Red Bull second drivers, but you'll never quite catch Max Verstappen!</p>

            <h3>Controls:</h3>
            <p>‚Ä¢ Hold Click/Tap for higher jumps</p>
            <p>‚Ä¢ Quick tap for small hops</p>
            <p>‚Ä¢ Watch the charge bar above your car!</p>

            <h3>Gameplay:</h3>
            <p>‚Ä¢ Jump over Red Bull cars to earn championship points</p>
            <p>‚Ä¢ The game gets faster and more challenging as you progress</p>
            <p>‚Ä¢ Don't crash into the Red Bull cars!</p>
        </div>
        <button class="menu-button back-button" onclick="showMainMenu()">Back</button>
    </div>

    <div id="credits">
        <h1 class="menu-title">Credits</h1>
        <div class="menu-content">
            <h3>Game Development:</h3>
            <p>Jordan Carter-Wightwick</p>

            <h3>Inspired by:</h3>
            <p>Charlotte's poor choice in F1 teams.</p>

            <h3>Special Thanks:</h3>
            <p>To all F1 fans who know the pain of watching Max dominate the sport!</p>

            <h3>Remember:</h3>
            <p>"It's lights out and away we go!" üèÅ</p>
        </div>
        <button class="menu-button back-button" onclick="showMainMenu()">Back</button>
    </div>

    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Oops! Max made McLaren look bad again!</p>
        <p id="finalScore">Final Score: 0</p>
        <button onclick="restartGame()">Try Again</button>
        <button class="back-button" onclick="showMainMenu()" style="margin-left: 10px;">Main Menu</button>
    </div>

    <!-- Audio Element -->
    <audio id="backgroundMusic" loop>
        <source src="./Resources/Audio/theme.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Device pixel ratio for sharp rendering on high-DPI displays
    let devicePixelRatio = window.devicePixelRatio || 1;
    let displayWidth, displayHeight;
    let canvasWidth, canvasHeight;

    // Audio setup
    const backgroundMusic = document.getElementById('backgroundMusic');
    const audioToggle = document.getElementById('audioToggle');
    let isAudioMuted = false;
    let audioInitialized = false;

    // Set initial volume
    backgroundMusic.volume = 0.3; // 30% volume to not be too loud

    // Frame rate management
    const TARGET_FPS = 60;
    const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
    let lastFrameTime = 0;
    let deltaTimeAccumulator = 0;

    // Function to initialize and start audio (needed for browser autoplay policies)
    function initializeAudio() {
        if (!audioInitialized && !isAudioMuted) {
            backgroundMusic.play().then(() => {
                audioInitialized = true;
                console.log('Audio initialized and playing successfully');
            }).catch(error => {
                console.log('Audio initialization failed:', error);
                // Try again on next user interaction
            });
        }
    }

    // Function to start audio if it's not muted
    function startAudio() {
        if (!isAudioMuted) {
            if (!audioInitialized) {
                initializeAudio();
            } else {
                backgroundMusic.play().catch(error => {
                    console.log('Failed to play audio:', error);
                });
            }
        }
    }

    // Toggle audio function
    function toggleAudio() {
        if (!audioInitialized) {
            initializeAudio();
        }

        isAudioMuted = !isAudioMuted;

        if (isAudioMuted) {
            backgroundMusic.pause();
            audioToggle.textContent = 'üîá';
            audioToggle.classList.add('muted');
            audioToggle.title = 'Unmute Audio';
        } else {
            backgroundMusic.play().catch(error => {
                console.log('Failed to play audio:', error);
            });
            audioToggle.textContent = 'üîä';
            audioToggle.classList.remove('muted');
            audioToggle.title = 'Mute Audio';
        }
    }

    // Set canvas size with proper scaling
    function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        const containerRect = container.getBoundingClientRect();

        displayWidth = containerRect.width;
        displayHeight = containerRect.height;

        // Set the internal size to the display size scaled by device pixel ratio
        canvasWidth = displayWidth * devicePixelRatio;
        canvasHeight = displayHeight * devicePixelRatio;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Scale the canvas back down using CSS
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';

        // Scale the drawing context so everything draws at the higher resolution
        ctx.scale(devicePixelRatio, devicePixelRatio);

        // Update game dimensions
        updateGameDimensions();
    }

    // Game state
    let gameState = 'menu'; // 'menu', 'intro', 'playing', 'gameOver'
    let gameRunning = false;
    let score = 0;
    let gameTime = 0; // Time-based instead of frame-based
    let introStartTime = 0;
    const introDuration = 3000; // 3 seconds

    // Background scrolling offset for smooth movement
    let backgroundOffset = 0;

    // Input tracking for seamless jump chaining
    let isInputDown = false;
    let chargeStartTime = 0;
    let wantsToCharge = false; // New flag for input buffering

    // McLaren player with variable jump (using relative sizing)
    const player = {
        x: 0, // Will be set relative to screen width
        y: 0,
        width: 0, // Will be set relative to screen size
        height: 0,
        velocityY: 0,
        grounded: false,
        minJumpPower: -8,
        maxJumpPower: -18,
        gravity: 0.8,
        isCharging: false,
        chargeTime: 0,
        maxChargeTime: 800 // milliseconds
    };

    const maxCar = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        speed: 0,
        visible: false
    };

    // Red Bull obstacles - improved spawn system
    const obstacles = [];
    let obstacleSpawnRate = 4000; // Start much slower (4 seconds between spawns)
    let obstacleSpeed = 150; // pixels per second
    let minObstacleGap = 0; // Will be set relative to screen width
    let lastObstacleTime = 0;
    let difficultyLevel = 0; // Track current difficulty level

    // Ground level
    let groundY;

    function updateGameDimensions() {
        // Set player size relative to screen
        player.width = displayWidth * 0.1; // 10% of screen width
        player.height = displayHeight * 0.067; // Maintain aspect ratio
        player.x = displayWidth * 0.125; // 12.5% from left edge

        maxCar.width = player.width;
        maxCar.height = player.height;
        maxCar.x = displayWidth * 0.225; // Start ahead of player

        groundY = displayHeight * 0.833; // 83.3% down the screen

        minObstacleGap = displayWidth * 0.225; // 22.5% of screen width

        if (!player.grounded) {
        } else {
            player.y = groundY - player.height;
        }
        maxCar.y = groundY - maxCar.height;
    }

    // Image loading code remains the same...
    const treeImage = new Image();
    let treeImageLoaded = false;
    treeImage.onload = function() { treeImageLoaded = true; };
    treeImage.onerror = function() { treeImageLoaded = false; };
    treeImage.src = './Resources/Sprites/tree_cartoon_med.png';

    const mclarenImage = new Image();
    const redBullImage = new Image();
    let mclarenImageLoaded = false;
    let redBullImageLoaded = false;
    mclarenImage.onload = function() { mclarenImageLoaded = true; };
    mclarenImage.onerror = function() { mclarenImageLoaded = false; };
    redBullImage.onload = function() { redBullImageLoaded = true; };
    redBullImage.onerror = function() { redBullImageLoaded = false; };
    mclarenImage.src = './Resources/Sprites/MCL.png';
    redBullImage.src = './Resources/Sprites/RB.png';

    const landoImage = new Image();
    const maxImage = new Image();
    let landoImageLoaded = false;
    let maxImageLoaded = false;
    landoImage.onload = function() { landoImageLoaded = true; updateDriverImages(); };
    landoImage.onerror = function() { landoImageLoaded = false; };
    maxImage.onload = function() { maxImageLoaded = true; updateDriverImages(); };
    maxImage.onerror = function() { maxImageLoaded = false; };
    landoImage.src = './Resources/Sprites/Lando.png';
    maxImage.src = './Resources/Sprites/Max.png';

    function updateDriverImages() {
        if (gameState === 'menu') {
            if (landoImageLoaded) {
                const landoImg = document.getElementById('landoImg');
                landoImg.src = landoImage.src;
                landoImg.style.display = 'block';
            }
            if (maxImageLoaded) {
                const maxImg = document.getElementById('maxImg');
                maxImg.src = maxImage.src;
                maxImg.style.display = 'block';
            }
        }
    }

    // Enhanced jump system with input buffering (time-based)
    function startCharging() {
        wantsToCharge = true;
        // Immediately start charging if already grounded
        if (player.grounded && !player.isCharging) {
            player.isCharging = true;
            chargeStartTime = gameTime;
        }
    }

    function stopCharging() {
        wantsToCharge = false;
        player.isCharging = false;
        chargeStartTime = 0;
    }

    function executeJump() {
        if (player.isCharging && player.grounded) {
            const chargeTime = gameTime - chargeStartTime;
            const chargeRatio = Math.min(chargeTime / player.maxChargeTime, 1);
            const jumpPower = player.minJumpPower + (player.maxJumpPower - player.minJumpPower) * chargeRatio;

            player.velocityY = jumpPower;
            player.grounded = false;
            player.isCharging = false;
            chargeStartTime = 0;

            // Ensure we're slightly off the ground to prevent immediate re-grounding
            if (player.y >= groundY - player.height) {
                player.y = groundY - player.height - 1;
            }

            // Keep wantsToCharge true if input is still held
            // This will trigger auto-charge on next landing
        }
    }

    // Draw McLaren with charge indicator
    function drawMcLaren(x, y) {
        if (mclarenImageLoaded && mclarenImage.complete) {
            const spriteAspectRatio = mclarenImage.width / mclarenImage.height;
            const scaledWidth = player.height * spriteAspectRatio;
            ctx.drawImage(mclarenImage, x, y, scaledWidth, player.height);
        } else {
            // Fallback
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(x, y, player.width, player.height);
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + player.width * 0.0625, y + player.height * 0.125, player.width * 0.1875, player.height * 0.2);
            ctx.fillRect(x + player.width * 0.75, y + player.height * 0.125, player.width * 0.1875, player.height * 0.2);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = player.height * 0.2;
            ctx.arc(x + player.width * 0.1875, y + player.height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + player.width * 0.8125, y + player.height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = `${player.height * 0.3}px Arial`;
            ctx.fillText('MCL', x + player.width * 0.3125, y + player.height * 0.625);
        }

        // Draw charge indicator (show when charging OR wanting to charge)
        if ((player.isCharging && (player.grounded || player.velocityY >= 0)) ||
            (wantsToCharge && !player.grounded)) {
            const chargeRatio = player.isCharging ?
                Math.min((gameTime - chargeStartTime) / player.maxChargeTime, 1) : 0;
            const barWidth = player.width * 0.75;
            const barHeight = displayHeight * 0.01;
            const barX = x + (player.width - barWidth) / 2;
            const barY = y - displayHeight * 0.025;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Charge bar or ready indicator
            if (player.isCharging) {
                const chargeWidth = barWidth * chargeRatio;
                if (chargeRatio < 0.5) {
                    ctx.fillStyle = '#00ff00';
                } else if (chargeRatio < 0.8) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                ctx.fillRect(barX, barY, chargeWidth, barHeight);
            } else if (wantsToCharge) {
                // Show "ready to charge" indicator
                ctx.fillStyle = '#00ffff'; // Cyan to indicate ready state
                ctx.fillRect(barX, barY, barWidth * 0.1, barHeight);
            }

            // Border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }

    // Draw Red Bull cars (updated for responsive sizing)
    function drawRedBull(x, y, width, height) {
        if (redBullImageLoaded && redBullImage.complete) {
            const spriteAspectRatio = redBullImage.width / redBullImage.height;
            const scaledWidth = height * spriteAspectRatio;
            ctx.drawImage(redBullImage, x, y, scaledWidth, height);
        } else {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(x + width * 0.0714, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillRect(x + width * 0.7571, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = height * 0.15;
            ctx.arc(x + width * 0.1714, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + width * 0.8286, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = `${height * 0.25}px Arial`;
            const textWidth = ctx.measureText('RB').width;
            ctx.fillText('RB', x + (width - textWidth) / 2, y + height * 0.625);
        }
    }

    function drawMaxRedBull(x, y, width, height) {
        if (redBullImageLoaded && redBullImage.complete) {
            const spriteAspectRatio = redBullImage.width / redBullImage.height;
            const scaledWidth = height * spriteAspectRatio;
            ctx.drawImage(redBullImage, x, y, scaledWidth, height);
        } else {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x + width * 0.0714, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillRect(x + width * 0.7571, y + height * 0.125, width * 0.1714, height * 0.15);
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            const wheelRadius = height * 0.15;
            ctx.arc(x + width * 0.1714, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.arc(x + width * 0.8286, y + height, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.font = `${height * 0.25}px Arial`;
            const textWidth = ctx.measureText('MV').width;
            ctx.fillText('MV', x + (width - textWidth) / 2, y + height * 0.625);
        }
    }

    // Menu functions
    function showMainMenu() {
        gameState = 'menu';
        gameRunning = false;
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('howToPlay').style.display = 'none';
        document.getElementById('credits').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('score').style.display = 'none';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('introText').style.display = 'none';
        updateDriverImages();
    }

    function showHowToPlay() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('howToPlay').style.display = 'block';
    }

    function showCredits() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('credits').style.display = 'block';
    }

    function startGame() {
        startAudio();

        gameState = 'intro';
        gameRunning = true;
        score = 0;
        gameTime = 0;
        introStartTime = 0;
        difficultyLevel = 0;
        backgroundOffset = 0; // Reset background scroll position

        player.y = groundY - player.height;
        player.velocityY = 0;
        player.grounded = true;
        player.isCharging = false;
        chargeStartTime = 0;

        maxCar.x = displayWidth * 0.225;
        maxCar.speed = 0;
        maxCar.visible = true;

        obstacles.length = 0;
        obstacleSpawnRate = 4000;
        obstacleSpeed = displayWidth * 0.1875; // 15% of screen width per second
        lastObstacleTime = 0;

        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('score').style.display = 'block';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('introText').style.display = 'block';

        requestAnimationFrame(gameLoop);
    }

    // Fixed background drawing functions with smooth scrolling (time-based)
    function drawTrees(deltaTime) {
        if (treeImageLoaded && treeImage.complete) {
            const treeSpacing = displayWidth * 0.25; // Space between trees relative to screen
            const scrollSpeed = displayWidth * 0.075; // Speed of tree movement per second

            // Update background offset for smooth scrolling (time-based)
            backgroundOffset += scrollSpeed * (deltaTime / 1000);

            // Calculate the starting position to ensure seamless wrapping
            const startX = -(backgroundOffset % treeSpacing);

            // Draw trees across the screen with some extra on both sides
            for (let i = startX - treeSpacing; i < displayWidth + treeSpacing; i += treeSpacing) {
                // Use the tree position to generate a consistent but varied appearance
                const treeSeed = Math.floor((i + backgroundOffset) / treeSpacing);
                const treeScale = 0.4 + (Math.sin(treeSeed) * 0.2);
                const treeWidth = (displayHeight * 0.15) * treeScale; // Relative to screen height
                const treeHeight = (displayHeight * 0.2) * treeScale;
                const treeY = groundY - treeHeight;

                ctx.drawImage(treeImage, i - treeWidth/2, treeY, treeWidth, treeHeight);
            }
        }
    }

    function drawBackground(deltaTime) {
        const gradient = ctx.createLinearGradient(0, 0, 0, displayHeight);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.7, '#98FB98');
        gradient.addColorStop(1, '#228B22');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        drawTrees(deltaTime);

        ctx.fillStyle = '#494241';
        ctx.fillRect(0, groundY, displayWidth, displayHeight - groundY);

        // Fixed road lines with smooth scrolling (time-based)
        ctx.fillStyle = 'white';
        const roadLineSpacing = displayWidth * 0.125;
        const roadScrollSpeed = displayWidth * 0.375; // pixels per second
        const roadOffset = ((gameTime * roadScrollSpeed) / 1000) % roadLineSpacing;

        for (let i = -roadOffset; i < displayWidth + displayWidth * 0.0625; i += roadLineSpacing) {
            ctx.fillRect(i, groundY - displayHeight * 0.0083, displayWidth * 0.0625, displayHeight * 0.005);
        }
    }

    // Update player physics with auto-charge on landing (time-based)
    function updatePlayer(deltaTime) {
        // Apply gravity (time-based)
        const gravityPerSecond = player.gravity * displayHeight; // Scale gravity to screen size
        player.velocityY += gravityPerSecond * (deltaTime / 1000);
        player.y += player.velocityY * (deltaTime / 1000);

        // Check for landing
        const wasGrounded = player.grounded;
        if (player.y >= groundY - player.height) {
            player.y = groundY - player.height;
            player.velocityY = 0;
            player.grounded = true;

            // Auto-start charging if player wants to charge and just landed
            if (!wasGrounded && wantsToCharge && !player.isCharging) {
                player.isCharging = true;
                chargeStartTime = gameTime;
            }
        } else {
            player.grounded = false;
        }
    }

    // Update Max's car during intro (time-based)
    function updateMaxCar(deltaTime) {
        if (gameState === 'intro') {
            if (gameTime > 1000) { // Start moving after 1 second
                const accelerationPerSecond = displayWidth * 0.125; // Acceleration per second
                maxCar.speed += accelerationPerSecond * (deltaTime / 1000);
                maxCar.x += maxCar.speed * (deltaTime / 1000);
            }
            if (maxCar.x > displayWidth + player.width * 1.25) {
                maxCar.visible = false;
            }
            if (gameTime >= introDuration) {
                gameState = 'playing';
                document.getElementById('introText').style.display = 'none';
                document.getElementById('instructions').style.display = 'block';
            }
        }
    }

    // Update obstacles with improved spawning logic (time-based)
    function updateObstacles(deltaTime) {
        if (gameState !== 'playing') return;

        const newDifficultyLevel = Math.floor(score / 5);

        if (newDifficultyLevel > difficultyLevel) {
            difficultyLevel = newDifficultyLevel;

            if (difficultyLevel <= 10) {
                obstacleSpawnRate = Math.max(2000, 4000 - (difficultyLevel * 150));
                obstacleSpeed = Math.min(displayWidth * 0.625, displayWidth * 0.1875 + (difficultyLevel * displayWidth * 0.03125));
                minObstacleGap = Math.max(displayWidth * 0.175, displayWidth * 0.225 - (difficultyLevel * displayWidth * 0.00625));
            } else {
                obstacleSpawnRate = Math.max(1000, 2000 - ((difficultyLevel - 10) * 50));
                obstacleSpeed = Math.min(displayWidth * 0.875, displayWidth * 0.625 + ((difficultyLevel - 10) * displayWidth * 0.025));
                minObstacleGap = Math.max(displayWidth * 0.15, displayWidth * 0.175 - ((difficultyLevel - 10) * displayWidth * 0.00625));
            }
        }

        // Spawn obstacles based on time
        if (gameTime - lastObstacleTime >= obstacleSpawnRate) {
            const canSpawn = obstacles.length === 0 ||
                (displayWidth - obstacles[obstacles.length - 1].x) >= minObstacleGap;

            if (canSpawn) {
                obstacles.push({
                    x: displayWidth,
                    y: groundY - player.height * 0.875,
                    width: player.width * 0.875,
                    height: player.height * 0.875
                });
                lastObstacleTime = gameTime;
            }
        }

        // Move obstacles (time-based)
        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].x -= obstacleSpeed * (deltaTime / 1000);
            if (obstacles[i].x + obstacles[i].width < 0) {
                obstacles.splice(i, 1);
                score += 1;
            }
        }
    }

    // Collision detection
    function checkCollisions() {
        if (gameState !== 'playing') return;
        for (let obstacle of obstacles) {
            if (player.x < obstacle.x + obstacle.width &&
                player.x + player.width > obstacle.x &&
                player.y < obstacle.y + obstacle.height &&
                player.y + player.height > obstacle.y) {
                gameRunning = false;
                showGameOver();
                return;
            }
        }
    }

    // Game loop with fixed timestep
    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        // Accumulate delta time
        deltaTimeAccumulator += deltaTime;

        // Fixed timestep update
        while (deltaTimeAccumulator >= TARGET_FRAME_TIME) {
            gameTime += TARGET_FRAME_TIME;

            updatePlayer(TARGET_FRAME_TIME);
            updateMaxCar(TARGET_FRAME_TIME);
            updateObstacles(TARGET_FRAME_TIME);
            checkCollisions();

            deltaTimeAccumulator -= TARGET_FRAME_TIME;
        }

        // Render
        ctx.clearRect(0, 0, displayWidth, displayHeight);

        drawBackground(deltaTime);
        drawMcLaren(player.x, player.y);

        if (gameState === 'intro' && maxCar.visible) {
            drawMaxRedBull(maxCar.x, maxCar.y, maxCar.width, maxCar.height);
        }

        if (gameState === 'playing') {
            for (let obstacle of obstacles) {
                drawRedBull(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
        }

        document.getElementById('score').textContent = `Championship points: ${score}`;
        requestAnimationFrame(gameLoop);
    }

    function showGameOver() {
        gameState = 'gameOver';
        gameRunning = false;
        document.getElementById('finalScore').textContent = `Final Score: ${score}`;
        document.getElementById('gameOver').style.display = 'block';
    }

    function restartGame() {
        startGame();
    }

    // Enhanced event listeners with input buffering
    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            startCharging();
        }
        // Initialize audio on first interaction
        if (!audioInitialized && !isAudioMuted) {
            initializeAudio();
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            executeJump();
            stopCharging();
        }
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            startCharging();
        }
        // Initialize audio on first interaction
        if (!audioInitialized && !isAudioMuted) {
            initializeAudio();
        }
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (gameState === 'playing') {
            executeJump();
            stopCharging();
        }
    });

    // Prevent touch scrolling and zooming
    document.addEventListener('touchstart', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !isInputDown) {
            e.preventDefault();
            if (gameState === 'playing') {
                isInputDown = true;
                startCharging();
            }
            // Initialize audio on first interaction
            if (!audioInitialized && !isAudioMuted) {
                initializeAudio();
            }
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && isInputDown) {
            e.preventDefault();
            if (gameState === 'playing') {
                isInputDown = false;
                executeJump();
                stopCharging();
            }
        }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
        // Debounce resize events
        clearTimeout(window.resizeTimeout);
        window.resizeTimeout = setTimeout(() => {
            devicePixelRatio = window.devicePixelRatio || 1;
            resizeCanvas();
        }, 100);
    });

    // Audio event listeners
    backgroundMusic.addEventListener('canplaythrough', () => {
        console.log('Audio is ready to play');
    });

    backgroundMusic.addEventListener('error', (e) => {
        console.log('Audio loading error:', e);
    });

    // Initialize canvas and start with main menu
    resizeCanvas();
    updateGameDimensions();
    player.y = groundY - player.height;
    player.grounded = true;
    showMainMenu();
</script>
</body>
</html>